#!/usr/bin/env bash
set -e
trap "exit 1" TERM
export TOP_PID=$$

# relies on the following:
#
# bash > ~3, test against 4 also (do any/some derivatives work? how to test?)
# egrep (version?)
# sed
# cut
# eval (shell built-in)
# which
# id
# uname
# curl | wget
# sudo | su

# potential to use for in-dev
#  awk
#  kill
#  fmt ?

version=0.1.0

command_exists() {
  command -v "$@" > /dev/null 2>&1
}

additional_warp_commands() {
  printf "\n--------\n\n"
  printf "Additional warp commands:\n\n"
  printf "alias\t\t Alias a function name to something else XXX TODO\n"
  printf "function\t Configure additional custom functions to be added XXX TODO\n"
  printf "install\t\t Install various ecosystem components including Docker\n"
  printf "original\t Show only original Docker command output XXX TODO\n"
  printf "uninstall\t Uninstall various ecosystem components including Docker\n"
  printf "update\t\t Update various ecosystem components including Docker\n\n"
  printf "Run 'docker COMMAND --help' for more information on a command.\n"
}

additional_custom_commands() {
  printf "\n--------\n\n"
  printf "Additional custom commands:\n\n"
  # XXX
  printf "Run 'docker COMMAND --help' for more information on a command.\n\n"
}

get_docker_commands() {
  DOCKER_COMMANDS=()
  out=$($(which docker))
  flag=0
  while read -r line; do
    if [ $flag == 1 ]; then
      comm=($line)
      comm="${comm[0]}"
      if [ "$comm" == "" ]; then
        flag=0
      else
        DOCKER_COMMANDS+=($comm)
      fi
    fi
    if [[ "$line" =~ ^Commands: ]]; then
      flag=1
    fi
  done <<< "$out"
}

get_compose_commands() {
  COMPOSE_COMMANDS=()
  # why is compose output to stderr instead of stdout!??!
  if [ $(which docker-compose) ]; then
    out=$(docker-compose 2>&1 | tee)
  else
    out=""
  fi
  flag=0
  while read -r line; do
    if [ $flag == 1 ]; then
      comm=($line)
      #comm="${comm[0]}"
      if [ "$comm" == "" ]; then
        flag=0
      else
        COMPOSE_COMMANDS+=($comm)
      fi
    fi
    if [[ "$line" =~ ^Commands: ]]; then
      flag=1
    fi
  done <<< "$out"
}

get_machine_commands() {
  MACHINE_COMMANDS=()
  out=$($(which docker-machine))
  flag=0
  while read -r line; do
    if [ $flag == 1 ]; then
      comm=($line)
      #comm="${comm[0]}"
      if [ "$comm" == "" ]; then
        flag=0
      else
        MACHINE_COMMANDS+=($comm)
      fi
    fi
    if [[ "$line" =~ ^Commands: ]]; then
      flag=1
    fi
  done <<< "$out"
}

run_native_docker_ecosystem() {
  docker_command=0
  compose_command=0
  machine_command=0
  if [ -n "$1" ]; then
    for i in "${DOCKER_COMMANDS[@]}"
    do
      if [ "$i" == "$1" ] ; then
        docker_command=1
      fi
    done
    if [ -n "$2" ]; then
      if [ "$1" == "compose" ]; then
        for i in "${COMPOSE_COMMANDS[@]}"
        do
          if [ "$i" == "$2" ] ; then
            compose_command=1
          fi
        done
      elif [ "$1" == "machine" ]; then
        for i in "${MACHINE_COMMANDS[@]}"
        do
          if [ "$i" == "$2" ] ; then
            machine_command=1
          fi
        done
      fi
    else
      if [ "$1" == "compose" ]; then
        out=$(docker-compose 2>&1 | tee)
        while read -r line; do
          echo "$line"
        done <<< "$out"
        additional_warp_commands
        additional_custom_commands
        kill -s TERM $TOP_PID
      elif [ "$1" == "machine" ]; then
        dkr_native="$(which docker-machine)"
        eval "$dkr_native"
        additional_warp_commands
        additional_custom_commands
        kill -s TERM $TOP_PID
      fi
    fi
  fi
  if [ "$docker_command" == 1 ]; then
    dkr_native="$(which docker) $*"
    eval "$dkr_native"
    kill -s TERM $TOP_PID
  elif [ "$compose_command" == 1 ]; then
    shift
    dkr_native="$(which docker-compose) $*"
    eval "$dkr_native"
    kill -s TERM $TOP_PID
  elif [ "$machine_command" == 1 ]; then
    shift
    dkr_native="$(which docker-machine) $*"
    eval "$dkr_native"
    kill -s TERM $TOP_PID
  else
    # checks only commands not in docker_commands
    for i in "${COMPOSE_COMMANDS[@]}"
    do
      if [ "$i" == "$1" ] ; then
        dkr_native="$(which docker-compose) $*"
        eval "$dkr_native"
        kill -s TERM $TOP_PID
      fi
    done
    for i in "${MACHINE_COMMANDS[@]}"
    do
      if [ "$i" == "$1" ] ; then
        dkr_native="$(which docker-machine) $*"
        eval "$dkr_native"
        kill -s TERM $TOP_PID
      fi
    done
  fi
}

warp_alias_command() {
  # XXX
  echo "TODO"
}

warp_function_command() {
  # XXX
  echo "TODO"
}

warp_original_command() {
  # XXX
  echo "TODO"
}

warp_install_command() {
  # read in $2 to see if it is docker, machine, compose, all, etc.
  if [ -n "$2" ]; then
    comm_exists=0
    for j in "${ecosystem[@]}"
    do
      if [ "$2" == "$j" ]; then
        if [[ $2 == "docker" || $2 == "all" ]]; then
          comm_exists=1
          echo "installing docker..."
          if command_exists docker; then
            echo "docker already installed, skipping..."
          else
            install_comm="$curl https://get.docker.io/ | sh"
            eval "$install_comm"
          fi
        fi
        # default to linux x86_64
        platform="linux"
        arch="amd64"
        path="/usr/bin"
        uhost=$(uname -sm)
        if [[ "$uhost" =~ ^Darwin ]]; then
          platform="darwin"
          path="/usr/local/bin"
        fi
        if [[ "$uhost" =~ i386 ]]; then
          arch="386"
        fi
        if [[ $2 == "machine" || $2 == "all" ]]; then
          comm_exists=1
          echo "installing machine..."
          if command_exists docker-machine; then
            echo "machine already installed, skipping..."
          else
            machine_url="https://github.com/docker/machine/releases/download/v0.3.0/docker-machine_$platform-$arch"
            install_comm="$sh_c '$curl $machine_url > $path/docker-machine'"
            eval "$install_comm"
            install_comm="$sh_c 'chmod +x $path/docker-machine'"
            eval "$install_comm"
          fi
        fi
        if [[ $2 == "compose" || $2 == "all" ]]; then
          comm_exists=1
          echo "installing compose..."
          if command_exists docker-compose; then
            echo "compose already installed, skipping..."
          else
            echo
            compose_url="https://github.com/docker/compose/releases/download/1.3.0/docker-compose-$(uname -s)-$(uname -m)"
            install_comm="$sh_c '$curl $compose_url > $path/docker-compose'"
            eval "$install_comm"
            install_comm="$sh_c 'chmod +x $path/docker-compose'"
            eval "$install_comm"
          fi
        fi
      fi
    done
    if [ "$comm_exists" == 0 ]; then
      printf "\nUsage: docker install [OPTIONS] TOOL\n\n"
      printf "Install Docker ecosystem tools\n\n"
      printf "Tools:\n"
      printf "\tdocker\t Install Docker\n"
      printf "\tcompose\t Install Docker Compose\n"
      printf "\tmachine\t Install Docker Machine\n"
      printf "\tall\t Install all Docker ecosystem tools\n"
    fi
  else
    printf "warp: \"$1\" requires 1 argument. See 'warp $1 --help'."
  fi
}

warp_uninstall_command() {
  # XXX
  echo "TODO"
}

warp_update_command() {
  # XXX
  echo "TODO"
}

run_warp_command() {
  warp_install_commands=("alias" "function" "install" "original" "uninstall" "update")
  ecosystem=("docker" "machine" "compose" "all")

  # begin credit to https://get.docker.com/
  user="$(id -un 2>/dev/null || true)"
  sh_c='sh -c'
  if [ "$user" != 'root' ]; then
    if command_exists sudo; then
      sh_c='sudo -E sh -c'
    elif command_exists su; then
      sh_c='su -c'
    else
      printf "Error: this installer needs the ability to run commands as root.\n"
      printf "We are unable to find either \"sudo\" or \"su\" available to make this happen.\n"
      exit 1
    fi
  fi

  curl=''
  if command_exists curl; then
    curl='curl -sSL'
  elif command_exists wget; then
    curl='wget -qO-'
  elif command_exists busybox && busybox --list-modules | grep -q wget; then
    curl='busybox wget -qO-'
  fi
  # end credit

  if [ -n "$1" ]
  then
    for i in "${warp_install_commands[@]}"
    do
      if [ "$1" == "$i" ]; then
        if [ "$1" == "alias" ]; then
          warp_alias_command "$@"
        elif [ "$1" == "function" ]; then
          warp_function_command "$@"
        elif [ "$1" == "install" ]; then
          warp_install_command "$@"
        elif [ "$1" == "original" ]; then
          warp_original_command "$@"
        elif [ "$1" == "uninstall" ]; then
          warp_uninstall_command "$@"
        elif [ "$1" == "update" ]; then
          warp_update_command "$@"
        fi
      fi
    done
  fi
}

read_args() {
  # no args, just print help
  if [ $# == 0 ]; then
    # docker is installed, print out docker help + warp help
    if command_exists docker; then
      (
        # testing 80 width output
        out=$($(which docker))
        while read -r line; do
          echo "$line" | cut -c1-80
        done <<< "$out"
        additional_warp_commands
        additional_custom_commands
      )
    # docker is not yet installed
    else
      printf "Usage: docker [OPTIONS] COMMAND [arg...]\n\n"
      printf "This is warp $version, Docker is not currently installed.\n\n"
      printf "Commands:\n\n"
      printf "install\t\t Install various ecosystem components including Docker\n"
      printf "uninstall\t Uninstall various ecosystem components including Docker\n"
      printf "update\t\t Update various ecosystem components including Docker\n\n"
      printf "Run 'docker COMMAND --help' for more information on a command.\n\n"
    fi
  # there are args, do something
  else
    # if docker is installed, get native commands for wrapping
    if command_exists docker; then
      (
        # docker is installed, get native docker commands
        # check command, if native docker command, pass off
        get_docker_commands

        if command_exists docker-compose ; then
          get_compose_commands
        fi
        if command_exists docker-machine ; then
          get_machine_commands
        fi
        run_native_docker_ecosystem "$@"
      )
    fi
    run_warp_command "$@"
  fi

  echo
}

loadcolors() {

  export _FG_BLACK="\033[0;30m"
  export _FG_DARK_GRAY="\033[1;30m"

  export _FG_RED="\033[0;31m"
  export _FG_BRIGHT_RED="\033[1;31m"

  export _FG_GREEN="\033[0;32m"
  export _FG_BRIGHT_GREEN="\033[1;32m"

  export _FG_YELLOW="\033[0;33m"
  export _FG_BRIGHT_YELLOW="\033[1;33m"

  export _FG_BLUE="\033[0;34m"
  export _FG_BRIGHT_BLUE="\033[1;34m"

  export _FG_MAGENTA="\033[0;35m"
  export _FG_BRIGHT_MAGENTA="\033[1;35m"

  export _FG_CYAN="\033[0;36m"
  export _FG_BRIGHT_CYAN="\033[1;36m"

  export _FG_WHITE="\033[0;37m"
  export _FG_BRIGHT_WHITE="\033[1;37m"

  export _BG_BLACK="\033[40m"
  export _BG_RED="\033[41m"
  export _BG_GREEN="\033[42m"
  export _BG_YELLOW="\033[43m"
  export _BG_BLUE="\033[44m"
  export _BG_MAGENTA="\033[45m"
  export _BG_CYAN="\033[46m"
  export _BG_WHITE="\033[47m"

  export _RESET="\033[0m"

  #printf "$_FG_GREEN""$_BG_BLUE""asdf""$_RESET"

}

getrc() {

  loadcolors

  # defaults, all easily overwritten with well-formed definitions in your very own ~/.warprc
  export WARP_WIDTH=80
  export WARP_ERROR_BG=$_BG_RED
  export WARP_ERROR_FG=$_FG_BRIGHT_WHITE

  if [ -f ~/.warprc ]
  then
    $(egrep '^WARP_[A-Z0-9_]+=[A-Za-z0-9]+$' ~/.warprc | sed -e 's/^/export /')
    #env | egrep ^WARP_
  fi

}

getrc
read_args "$@"

exit 0
